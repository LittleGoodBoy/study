---

typora-copy-images-to: 队列
typora-root-url: 队列
---

# 队列

## Queue

```java
public interface Queue<E> extends Collection<E> {
    // offer，add区别： 一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。 这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。
    boolean add(E var1);
    boolean offer(E var1);
    // poll，remove区别： remove() 和 poll() 方法都是从队列中删除第一个元素（head）。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。
    E remove();
    E poll();
    // peek，element区别： element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。
    E element();
    E peek();
}
```

​	有界阻塞队列包括：ArrayBlockingQueue、LinkedBlockingQueue以及LinkedBlockingDeque三种，LinkedBlockingDeque应用场景很少，一般用在“工作窃取”模式下。ArrayBlockingQueue和LinkedBlockingQueue基本就是数组和链表的区别。

​	无界队列包括PriorityBlockingQueue、DelayQueue和LinkedTransferQueue。PriorityBlockingQueue用在需要排序的队列中。DelayQueue可以用来做一些定时任务或者缓存过期的场景。LinkedTransferQueue则相比较其他队列多了transfer功能。最后剩下一个不存储元素的队列SynchronousQueue，用来处理一些高效的传递性场景。

## 非阻塞队列

### ArrayDeque（数组双端队列）

`ArrayDeque`采用了循环数组的方式来完成双端队列的功能。

- 当头尾索引相遇的时候，两倍扩容
- 非线程安全的，不支持并发访问和修改。
- 支持fast-fail.
- 作为栈使用的话比比栈要快,当队列使用比linklist要快。
- 不允许null值
- 对头尾添加删除元素效率很高。但是删除中间元素的话，需要拷贝数组。拷贝头和尾距离删除元素位置近的那一段，为了提高效率。
- 默认数组大小是8

### PriorityQueue（优先级队列）

​	`PriorityQueue` 类实质上维护了一个有序列表。加入到 `Queue` 中的元素根据它们的天然排序（通过其 `java.util.Comparable` 实现）或者根据传递给构造函数的 `java.util.Comparator` 实现来定位。

### ConcurrentLinkedQueue（单端基于链表的非阻塞队列）

​	`ConcurrentLinkedQueue` 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小，`ConcurrentLinkedQueue` 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。

### ConcurrentLinkedDeque（双端基于链表的非阻塞队列）





## 阻塞队列

`BlockingQueue`的核心方法：

​	`BlockingQueue` 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：

​	1、抛出异常；

​	2、返回特殊值（null 或 true/false，取决于具体的操作）；

​	3、阻塞等待此操作，直到这个操作成功；

​	4、阻塞等待此操作，直到成功或者超时指定时间。

|      | **抛出异常** | **特殊值** | **阻塞**         | **超时**             |
| ---- | ------------ | ---------- | ---------------- | -------------------- |
| 插入 | add(e)       | offer(e)   | put(e)           | offer(e, time, unit) |
| 删除 | remove()     | poll()     | take()           | poll(time, unit)     |
| 获取 | element()    | peek()     | *not applicable* | *not applicable*     |

放入数据：

　　offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,
　　　　则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）
　　offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中
　　　　加入BlockingQueue，则返回失败。
　　put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断
　　　　直到BlockingQueue里面有空间再继续.
获取数据：
　　poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,
　　　　取不到时返回null;
　　poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，
　　　　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。
　　take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到
　　　　BlockingQueue有新的数据被加入; 
　　drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 
　　　　通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。

![image-20240110100948431](image-20240110100948431.png)

### 1、ArrayBlockingQueue

​	（基于数组的并发阻塞队列） 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。

​	基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了 一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。
　　 ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于 LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的 完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任 何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而 在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。

#### ① 类定义

```Java
public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
final Object[] items;				// 队列元素存储的数组
int takeIndex;						// 出队时的下标
int putIndex;						// 入队时的下标
int count;							// 队列中元素的总数
final ReentrantLock lock;			// 入队和出队锁, 同一把锁
private final Condition notEmpty;	// 非空条件
private final Condition notFull;	// 非满条件
```

#### ③ 构造

```Java
// 指定初始容量
public ArrayBlockingQueue(int var1) {
    this(var1, false);
}
// 指定初始容量以及是否使用公平锁
public ArrayBlockingQueue(int var1, boolean var2) {
    this.itrs = null;
    if (var1 <= 0) {
        throw new IllegalArgumentException();
    } else {
        this.items = new Object[var1];
        this.lock = new ReentrantLock(var2);
        this.notEmpty = this.lock.newCondition();
        this.notFull = this.lock.newCondition();
    }
}
// 从一个集合将数据同步到指定大小并且指定是否公平的队列中
public ArrayBlockingQueue(int var1, boolean var2, Collection<? extends E> var3) {
```

#### ④ add/peek

​	add/peek是一对互斥的操作，add向队列种放入元素，peek取出元素。

```Java
public boolean add(E var1) {
    return super.add(var1);
}
// super.add(var1)
public boolean add(E var1) {
    // 其实就是调用的offer方法,  只是当offer成功了返回true, 失败了抛异常提示队列满了
    if (this.offer(var1)) { 
        return true;
    } else {
        throw new IllegalStateException("Queue full");
    }
}

public E peek() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        // 只是返回出队的元素, 并不真正执行出队逻辑, 元素还在队列中
        var2 = this.itemAt(this.takeIndex);
    } finally {
        var1.unlock();
    }
    return var2;
}
final E itemAt(int var1) {
    return this.items[var1];
}
```

#### ⑤ offer/poll

​	offer/poll是一对互斥的操作，offer向队列种放入元素，poll取出元素

```Java
public boolean offer(E var1) {
    checkNotNull(var1); // 检查, 如果添加的元素为null, 就抛空指针异常
    ReentrantLock var2 = this.lock;
    var2.lock();	// 加锁

    boolean var3;
    try {
        // 当记录的队列总数(count默认为0)与队列长度不一致时, 表示队列没有满, 可以入队
        if (this.count != this.items.length) {
            this.enqueue(var1); // 入队的方法
            var3 = true;
            return var3;
        }
        var3 = false; // 队列满了直接返回false
    } finally {
        var2.unlock(); // 释放锁
    }
    return var3;
}
// 入队的方法, 将元素从数组的下标为0开始添加
private void enqueue(E var1) {
    Object[] var2 = this.items;
    var2[this.putIndex] = var1;
    if (++this.putIndex == var2.length) {
        this.putIndex = 0;
    }

    ++this.count;
    this.notEmpty.signal();
}

public E poll() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        var2 = this.count == 0 ? null : this.dequeue();
    } finally {
        var1.unlock();
    }
    return var2;
}

private E dequeue() {
    Object[] var1 = this.items;
    Object var2 = var1[this.takeIndex];
    var1[this.takeIndex] = null;
    if (++this.takeIndex == var1.length) {
        this.takeIndex = 0;
    }
    --this.count;
    if (this.itrs != null) {
        this.itrs.elementDequeued();
    }
    this.notFull.signal();
    return var2;
}
```

offer/poll，带超时的入队出队

```Java
public boolean offer(E var1, long var2, TimeUnit var4) throws InterruptedException {
    checkNotNull(var1);
    long var5 = var4.toNanos(var2);
    ReentrantLock var7 = this.lock;
    var7.lockInterruptibly(); // 允许打断, 会抛出InterruptedException
    boolean var8;
    try {
        while(this.count == this.items.length) { // 队列满时
            if (var5 <= 0L) {
                var8 = false;
                return var8; // 超时返回false
            }
            var5 = this.notFull.awaitNanos(var5); // 超时的notFull条件等待
        }
        this.enqueue(var1); // 未超时, 并且队列未满则入队
        var8 = true;
    } finally {
        var7.unlock();
    }
    return var8;
}

public E poll(long var1, TimeUnit var3) throws InterruptedException {
    long var4 = var3.toNanos(var1);
    ReentrantLock var6 = this.lock;
    var6.lockInterruptibly();

    try {
        Object var7;
        while(this.count == 0) {
            if (var4 <= 0L) {
                var7 = null;
                return var7; // 超时返回null
            }

            var4 = this.notEmpty.awaitNanos(var4); // 带超时的notEmpty条件等待
        }

        var7 = this.dequeue(); // 出队
        return var7;
    } finally {
        var6.unlock();
    }
}
```

#### ⑥ put/take

​	put/take是一对互斥的操作，put向队列种放入元素，take取出元素,其实现方式和add/peek不一样。

```Java
public void put(E var1) throws InterruptedException {
    checkNotNull(var1);
    ReentrantLock var2 = this.lock;
    var2.lockInterruptibly();  // 允许被打断, 会抛出InterruptedException
    try {
        while(this.count == this.items.length) {
            this.notFull.await(); // 队列满了, 则notFull条件等待
        }
        this.enqueue(var1); // 否则入队, 根据putIndex的位置添加数据到数组
    } finally {
        var2.unlock();
    }
}

public E take() throws InterruptedException {
    ReentrantLock var1 = this.lock;
    var1.lockInterruptibly();
    Object var2;
    try {
        while(this.count == 0) {
            this.notEmpty.await(); // 队列为空，则notEmpty条件等待
        }
        var2 = this.dequeue();// 否则队列有数据, 就正常出队
    } finally {
        var1.unlock();
    }
    return var2;
}
```

#### ⑦ 添加方法比较

| 序号 | 方法名                                  | 队列满时处理方式                        | 方法返回值 |
| ---- | --------------------------------------- | --------------------------------------- | ---------- |
| 1    | add(E e)                                | 抛出“Queue full”异常                    | boolean    |
| 2    | offer(E e)                              | 返回false                               | boolean    |
| 3    | put(E e)                                | 线程阻塞，直到中断或被唤醒              | void       |
| 4    | offer(E e, long timeout, TimeUnit unit) | 在规定时间内重试，超过规定时间返回false | boolean    |

#### ⑧ 取出方法比较

| 序号 | 方法名                            | 队列空时处理方式                       | 方法返回值 |
| ---- | --------------------------------- | -------------------------------------- | ---------- |
| 1    | peek()                            | 返回null                               | E          |
| 2    | poll()                            | 返回null                               | E          |
| 3    | take()                            | 线程阻塞，指定中断或被唤醒             | E          |
| 4    | poll(long timeout, TimeUnit unit) | 在规定时间内重试，超过规定时间返回null | E          |

### 2、LinkedBlockingQueue 

​	LinkedBlockingQueue是一个底层用单向链表实现的有界阻塞队列，和ArrayBlockingQueue一样，采用ReentrantLock来控制并发，不同的是它使用了两个独占锁来控制消费和生产

​	（基于链表的FIFO阻塞队列）底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。

​		基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列 中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时 （LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
​		作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认 一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。

#### ① 类定义

```Java
public class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
private final int capacity;							// 定义队列容量
private final AtomicInteger count;					// 队列实际大小
transient LinkedBlockingQueue.Node<E> head;			// 头节点
private transient LinkedBlockingQueue.Node<E> last;	// 尾节点
private final ReentrantLock takeLock;				// 出队锁
private final Condition notEmpty;					// 非空条件
private final ReentrantLock putLock;				// 入队锁
private final Condition notFull;					// 非满条件
```

#### ③ 构造

```Java
// 无参构造默认大小为Integer最大值
public LinkedBlockingQueue() {
    this(2147483647);
}
// 有参构造, 根据指定的队列大小初始化队列
public LinkedBlockingQueue(int var1) {
    this.count = new AtomicInteger();
    this.takeLock = new ReentrantLock();
    this.notEmpty = this.takeLock.newCondition();
    this.putLock = new ReentrantLock();
    this.notFull = this.putLock.newCondition();
    if (var1 <= 0) {
        throw new IllegalArgumentException();
    } else {
        this.capacity = var1;
        this.last = this.head = new LinkedBlockingQueue.Node((Object)null);
    }
}
// 有参构造, 根据一个集合初始化队列, 默认大小为Integer最大值
public LinkedBlockingQueue(Collection<? extends E> var1) {
    this(2147483647);
}
```

#### ④ offer/poll

```Java
/** 向队列中添加元素，但是不会阻塞 */
public boolean offer(E e) {
    // 判空
    if (e == null) 
        throw new NullPointerException();
    // 获取记录元素数量的count变量
    final AtomicInteger count = this.count;
    // 如果当前队列已经满了，则直接返回false，不进行添加
    if (count.get() == capacity)
        return false;
    
    // 此变量的作用于put方法中一致
    int c = -1;
    // 封装成Node
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    // 因为是添加元素，所以使用put锁进行锁定，这里调用的lock()方法
    // lock方法不响应中断，这里不需要响应中断，所以选择使用lock，
    // 不需要响应中断是因为这个方法并不会阻塞线程
    putLock.lock();
    try {
        // 再次判断当前队列是否满了，为什么再次判断？
        // 因为在上一次判断后，CPU可能暂停了当前线程，转而执行其他线程
        // 在这个过程中可能有其他线程向队列中添加了元素
        if (count.get() < capacity) {
            // 调用enqueue方法将元素添加到队列的尾部
            enqueue(node);
            // 获取入队前的队列总数, 然后count+1
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                // 当入队后总数小于容量, 表示队列还有位置, 则唤醒一个由于队列满了等待入队的线程
                notFull.signal();
        }
    } finally {
        // 解锁
        putLock.unlock();
    }
    // 当入队前如果入队总数为0, 很可能存在消费线程, 所以唤醒一个由于队列为空等待出队的线程
    if (c == 0)
        signalNotEmpty();
    // c记录的是添加前，队列中元素的个数，不可能出现负数，所以此处返回的一定是true
    return c >= 0;
}


public E poll() {
    AtomicInteger var1 = this.count;
    if (var1.get() == 0) {
        return null; // 队列没有数据, 直接返回null
    } else {
        Object var2 = null;
        int var3 = -1;
        ReentrantLock var4 = this.takeLock;
        var4.lock();

        try {
            if (var1.get() > 0) { // 队列不为空
                // 队列不为空时, 出队
                var2 = this.dequeue();
                // 获取入队前的历史总数, 然后var自减
                var3 = var1.getAndDecrement();//var3记录的是出队前的总数
                if (var3 > 1) {
                    // 当队列仍有数据的时候, 唤醒一个由于队列空了等待出队的线程
                    this.notEmpty.signal();
                }
            }
        } finally {
            var4.unlock();
        }
        // 当出队前队列就是满的, 此时很可能存在要入队的线程
        if (var3 == this.capacity) {
            // 所以当出队前就是满的, 则唤醒一个由于队列满了等待入队的线程
            this.signalNotFull();
        }
        return var2;
    }
}
```

offer/poll，带超时的入队出队

```Java
/**
 * 此方法向队列中添加元素，若队列已经满了，则线程被阻塞，但是参数中限制了阻塞时间
 * 若超时后，当前线程还没有添加成功，则不继续等待，直接返回
 * 参数：
 * 	1、timeout：超时时间的数量级，一个long类型的整数
 *	2、unit：timeout的单位，例如TimeUnit.SECOND表示的就是秒
*/
public boolean offer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {
    
    if (e == null) 
        throw new NullPointerException();
    // 将超时时间转换为纳秒
    long nanos = unit.toNanos(timeout);
    // 以下几句与put方法相同
    int c = -1;
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        // 若当前队列已经满了，则线程需要进入等待
        while (count.get() == capacity) {
            // 判断等待的剩余时间是否<=0，若满足此条件，表示等待时间已经超时
            if (nanos <= 0)
                return false;
            // 使用notFull对象让当前线程阻塞，传入需要阻塞的时间，但是这个方法并不精确
            // 所以会返回剩余需要阻塞的时间，这也就是为什么上一句需要判断nanos <= 0
            nanos = notFull.awaitNanos(nanos);
        }
        // 以下操作和put相同
        enqueue(new Node<E>(e));
        c = count.getAndIncrement();
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
    return true;
}

/**
 * 此方法向队列中获取元素，若队列为空线程将会被阻塞，但是需要指定超时时间，
 * 超时后，线程还未获取元素，直接返回；
 * 参数timeout和unit的含义与会超时的offer方法相同，
 * 分别表示超时时间的数量级，已经时间的单位
*/
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    E x = null;
    int c = -1;
    // 将超时时间转换为纳秒
    long nanos = unit.toNanos(timeout);
    // 以下方法与take方法相同，不重复解释
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        // 若队列为空，则线程需要等待
        while (count.get() == 0) {
            // 判断等待的剩余时间，若剩余时间<=0，表示已经超时，直接返回null
            if (nanos <= 0)
                return null;
            // 让当前线程在notEmpty中的等待nanos纳秒，因为awaitNanos方法不精确，
            // 所以这个方法会返回一个值，表示剩余需要等待的时间，所以才有了上一句的if
            nanos = notEmpty.awaitNanos(nanos);
        }
        // 以下代码与take相同，不重复解释
        x = dequeue();
        c = count.getAndDecrement();
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}
```

#### ⑤ put/take

```Java

public void put(E e) throws InterruptedException {
    // 新元素不能为空
    if (e == null) 
        throw new NullPointerException();
    
    // 初始化一个c变量，后面用于记录插入新元素前，队列中元素的个数
    int c = -1;
    // 将新元素封装成一个Node
    Node<E> node = new Node<E>(e);
    // 因为是添加元素，所以这里使用put锁进行线程同步，先获取put锁
    final ReentrantLock putLock = this.putLock;
    // 获取记录元素个数的变量
    final AtomicInteger count = this.count;
    
    // 在正式操作前，先使用putLock加锁，调用的是lockInterruptibly方法
    // 这个方法在在线程被阻塞时可以响应中断，使用它是防止线程一直无法添加成功，
    // 长期被阻塞在此处
    putLock.lockInterruptibly();
    try {
        // 添加元素前线判断队列中元素是否已经满了，
        // 若满了则使用notFull对象，让当前线程阻塞，直到被另一个线程唤醒
        // 使用while而不是if，目的是防止线程被唤醒时，
        // 队列仍然是满的，所以需要重复判断
        while (count.get() == capacity) {
            notFull.await();
        }
        
        // 调用enqueue方法将新节点加入队列的尾部
        enqueue(node);
        // getAndIncrement方法返回count的旧值，然后让count+1
        c = count.getAndIncrement();
        
        /**************关键点1****************/
        // c + 1就是插入当前这个节点后，队列中元素的数量
        // 若插入这个元素后，队列依旧没有满，则唤醒一个生产者线程
        // 也就是向队列中添加元素的线程（前提是有这么一个线程）。
        // 为什么是在添加一个元素后，唤醒另外一个生产者线程，
        // 而不是在有线程获取元素后，唤醒一个生产者线程呢，这不是才正常吗？
        // 答案就是消费者线程使用的是take锁，而唤醒生产者线程需要的是put锁，
        // 为了减少额外加锁解锁的次数，我们就可以在这里唤醒生产者线程，
        // 因为这里在添加元素前，已经获取了put锁了，不需要重复获取。
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        // 解锁
        putLock.unlock();
    }
    
    /**************关键点2****************/
    // c表示插入之前，队列中元素的个数，若插入之前c == 0，
    // 表示在插入前，队列是空，意味着很有可能存在正在等待的消费者线程
    // 于是调用signalNotEmpty方法唤醒一个消费者线程。
    // 可以看到，只有当添加元素之前，队列为空，这里才会唤醒一个消费者线程。
    // 但是可能有多个消费者线程在等待，此时唤醒一个，那剩下的那些怎么办？
    // 答案就是可以在获取元素的方法中唤醒它们，原理就是上面那段很长的注释
    if (c == 0)
        signalNotEmpty();
}
 
/** 此方法将节点加入到链表的末尾 */
private void enqueue(Node<E> node) {
    /*
     * 以下代码可以分解为：
     * last.next = node;
     * last = node
     * 由于构造方法中 this.last = this.head = new LinkedBlockingQueue.Node((Object)null);
     * 所以当第一个元素入队的时候, last.next = node, 也就修改了head的next的指向, 指向了node
     * 然后last = node, 记录最后一个节点的值, head头节点中保存的元素为null, next指向队列第一个元素
     */
    last = last.next = node;
}
 
/** 此方法用于唤醒一个消费者线程 */
private void signalNotEmpty() {
    // 因为消费者线程是获取元素，所以使用的是take锁
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        // notEmpty由take锁创建，所以需要先锁定take锁，再调用signal方法
        // 否则将抛出异常
        notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
}


public E take() throws InterruptedException {
    E x;
    // 此变量的作用与put方法中一致，用来记录插入前，队列中元素的个数
    int c = -1;
    final AtomicInteger count = this.count;
    // 由于是向队列中获取元素，所以使用的是take锁
    final ReentrantLock takeLock = this.takeLock;
    
    // 实际操作前先锁定，调用lockInterruptibly锁定，且这个方法响应中断
    // 此处需要响应中断，因为这个方法会阻塞线程
    takeLock.lockInterruptibly();
    try {
        // 若队列为空，则当前线程需要等待，直到被其他线程唤醒
        while (count.get() == 0) {
            notEmpty.await();
        }
        // 调用dequeue获取队列的队头元素
        x = dequeue();
        // 获得count的值，然后count + 1
        c = count.getAndDecrement();
        
        /*************关键点1***************/
        // 若队列中原来的元素数量>1，则表示当前线程拿走一个元素后，队列中还有元素
        // 于是此处唤醒其他消费者线程，让他们获取元素
        // 此处很关键，对应着put方法中的关键点2（注意是put，而不是此方法take），put方法中，
        // 只有添加元素前，队列为空，才会唤醒一个消费者线程，而剩余的消费者线程在此处唤醒
        // 因为这里已经拿到了take锁，不需要为了唤醒消费者线程再次获取take锁
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    
    /*******************关键点2*******************/
    // 此处判断，若在获取元素之前，队列是满的，那说明很有可能有生产者线程在等待
    // 因为这里拿走了一个元素，所以队列有空位了，于是就唤醒一个生产者线程，添加元素
    // 值得注意的是，等待的生产者线程可能不止一个，这里只唤醒了一个，剩下的怎么办，
    // 答案就在put方法的关键点2那里，由put方法唤醒了剩下的生产者线程
    if (c == capacity)
        signalNotFull();
    return x;
}
 
/** 此方法获取队列头节点的值，并将头节点从队列删除 */
private E dequeue() {
    // 获取头节点
    Node<E> h = head;
    // 获取头节点的下一个节点
    Node<E> first = h.next;
    // 让头节点指向自己，也就是让头节点从链表上断开
    h.next = h; // help GC
    // 设置新的头节点，也就是原来头节点的下一个节点
    head = first;
    // 获取原来头节点的值
    E x = first.item;
    // 将原来头节点的值置为空，有助于垃圾回收
    first.item = null;
    // 返回结果
    return x;
}
```

#### ⑥ peek

```Java
public E peek() {
    if (this.count.get() == 0) {
        return null; // 当队列为空, 直接返回null
    } else {
        ReentrantLock var1 = this.takeLock;
        var1.lock();
        Object var3;
        try {
            LinkedBlockingQueue.Node var2 = this.head.next;
            // 当头节点的下一个节点不为空, 则返回节点内容
            if (var2 != null) {
                var3 = var2.item;
                return var3;
            }
            var3 = null;
        } finally {
            var1.unlock();
        }
        return var3;
    }
}
```



### 3、DelayQueue

​	（延期阻塞队列）

​		DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。
使用场景：
　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。

#### ① 类定义

```Java
public class DelayQueue<E extends Delayed> extends AbstractQueue<E> implements BlockingQueue<E> {
```

#### ② 成员变量

```Java
//用于保证队列操作的线程安全
private final transient ReentrantLock lock = new ReentrantLock();
// 优先级队列,存储元素，用于保证延迟低的优先执行
private final PriorityQueue<E> q = new PriorityQueue<E>();
// 用于标记当前是否有线程在排队（仅用于取元素时） leader 指向的是第一个从队列获取元素阻塞的线程
private Thread leader = null;
// 条件，用于表示现在是否有可取的元素   当新元素到达，或新线程可能需要成为leader时被通知
private final Condition available = lock.newCondition();
```

#### ③ 构造

```Java
public DelayQueue() {
    this.available = this.lock.newCondition();
}

public DelayQueue(Collection<? extends E> var1) {
    this.available = this.lock.newCondition();
    this.addAll(var1);
}
```

#### ④ offer/poll

```Java
public boolean add(E var1) {
    return this.offer(var1);
}

public boolean offer(E var1, long var2, TimeUnit var4) {
    return this.offer(var1);
}
public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 入队
        q.offer(e);
        if (q.peek() == e) {
            // 若入队的元素位于队列头部，说明当前元素延迟最小
            // 将 leader 置空
            leader = null;
            // available条件队列转同步队列,准备唤醒阻塞在available上的线程
            available.signal();
        }
        return true;
    } finally {
        lock.unlock(); // 解锁，真正唤醒阻塞的线程
    }
}

public E poll() {
    ReentrantLock var1 = this.lock;
    var1.lock();

    Delayed var3;
    try {
        Delayed var2 = (Delayed)this.q.peek();
        if (var2 != null && var2.getDelay(TimeUnit.NANOSECONDS) <= 0L) {
            var3 = (Delayed)this.q.poll();
            return var3;
        }

        var3 = null;
    } finally {
        var1.unlock();
    }

    return var3;
}
```

#### ⑤ put/take

```Java
public void put(E e) {
    offer(e);
}
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        for (;;) {
            E first = q.peek();// 取出堆顶元素   
            if (first == null)// 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待
                available.await();
            else {
                long delay = first.getDelay(NANOSECONDS);// 堆顶元素的到期时间             
                if (delay <= 0)// 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素
                    return q.poll();
                
                // 如果delay大于0 ，则下面要阻塞了
                // 将first置为空方便gc
                first = null; 
                // 如果前面有其它线程在等待，直接进入等待
                if (leader != null)
                    available.await();
                else {
                    // 如果leader为null，把当前线程赋值给它
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;
                    try {
                        // 等待delay时间后自动醒过来
                        // 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期
                        // 这里即使醒过来后也不一定能获取到元素
                        // 因为有可能其它线程先一步获取了锁并弹出了堆顶元素
                        // 条件锁的唤醒分成两步，先从Condition的队列里出队
                        // 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒
                        available.awaitNanos(delay);
                    } finally {
                        // 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {
        // 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程
        if (leader == null && q.peek() != null)
            // available条件队列转同步队列,准备唤醒阻塞在available上的线程
            available.signal();
        // 解锁，真正唤醒阻塞的线程
        lock.unlock();
    }
}
```

#### ⑥ 使用场景

​	缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。

​	定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。

#### ⑦ 总结

DelayQueue其实采用了装饰器模式，在对PriorityQueue进行包装下增加了延时时间获取元素的功能，其主要特点归纳如下：

- DelayQueue是一个无界阻塞队列，队列内部使用PriorityQueue来实现。

- 进入队列的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从中提取元素；

- 该队列头部是延迟期满后保存时间最长的Delayed元素；

- 如果没有延迟未过期元素，且队列没有头部，并且poll将返回null；

- 当一个元素的getDelay（TimeUnit.NANOSECONDS）方法返回一个小于等于0的值时，表示该元素已过期；

- 无法使用poll或take移除未到期的元素，也不会将这些元素作为正常元素对待；例如：size方法返回到期和未到期元素的计数之和。

- 此队列不允许使用null元素。



### 4、PriorityBlockingQueue 

​	（带优先级的无界阻塞队列）无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。

​		基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度， 否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。

#### ① 类定义

```Java
public class PriorityBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
// 默认的数组容量。
private static final int DEFAULT_INITIAL_CAPACITY = 11;

/**
 * The maximum size of array to allocate. 要分配的数组的最大大小。
 * Some VMs reserve some header words in an array. 一些vm在数组中保留一些头信息
 * Attempts to allocate larger arrays may result in
 * OutOfMemoryError: Requested array size exceeds VM limit
   尝试分配更大的数组可能会导致OutOfMemoryError:请求的数组大小超过VM限制
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
   优先级队列表现为一个平衡的二进制堆：queue[n]的两个子队列是queue[2*n+1]和queue[2*(n+1)]。
   优先级队列通过comparator或元素的自然顺序排序，如果comparator为null:对于堆中的每个节点n和n的每个子节点d, n <= d。假设队列非空，则queue[0]中的值最小。
 */
private transient Object[] queue;

// 优先级队列中的元素个数。
private transient int size;

// 比较器，如果优先级队列使用元素的自然顺序排序，则为null。
private transient Comparator<? super E> comparator;

// 用于所有公共操作的锁
private final ReentrantLock lock;

/**
 * Condition for blocking when empty
 */
private final Condition notEmpty;

/**
 * Spinlock for allocation, acquired via CAS. 用于分配的自旋锁，通过CAS获取。
 */
private transient volatile int allocationSpinLock;

/**
   一个普通的PriorityQueue，仅用于序列化，以保持与该类以前版本的兼容性。
   仅在序列化/反序列化期间非空。
 */
private PriorityQueue<E> q;
```

#### ③ 构造

```Java
public PriorityBlockingQueue() {
    this(11, (Comparator)null);
}

public PriorityBlockingQueue(int var1) {
    this(var1, (Comparator)null);
}

public PriorityBlockingQueue(int var1, Comparator<? super E> var2) {
    if (var1 < 1) {
        throw new IllegalArgumentException();
    } else {
        this.lock = new ReentrantLock();
        this.notEmpty = this.lock.newCondition(); 	// 为空的线程等待条件
        this.comparator = var2;						// 比较器
        this.queue = new Object[var1];				// 指定大小的存储队列数据的数组
    }
}
```

#### ④ offer/poll

```Java
public boolean add(E var1) {
    return this.offer(var1);
}

public boolean offer(E var1) {
    if (var1 == null) {
        throw new NullPointerException();
    } else {
        ReentrantLock var2 = this.lock;
        var2.lock();
        int var3;
        int var4;
        Object[] var5;
        while((var3 = this.size) >= (var4 = (var5 = this.queue).length)) {
            this.tryGrow(var5, var4);
        }
        try {
            // 根据比较器来实现优先级排序
            Comparator var6 = this.comparator;
            if (var6 == null) {
                siftUpComparable(var3, var1, var5);
            } else {
                siftUpUsingComparator(var3, var1, var5, var6);
            }
            this.size = var3 + 1;
            this.notEmpty.signal(); // 放入元素后通知阻塞的消费线程
        } finally {
            var2.unlock();
        }
        return true;
    }
}

public E poll() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        var2 = this.dequeue();
    } finally {
        var1.unlock();
    }
    return var2;
}


/**
 * 扩容
 * Tries to grow array to accommodate at least one more element
 * (but normally expand by about 50%), giving up (allowing retry)
 * on contention (which we expect to be rare). Call only while
 * holding lock.
   尝试扩展数组以容纳至少一个以上元素(但通常扩展50%)，在争用时放弃(允许重试)(我们希望这种情况很少见)。
   只有在持有锁的状态下才调用。
 * @param array the heap array
 * @param oldCap the length of the array
 */
private void tryGrow(Object[] array, int oldCap) {
    lock.unlock(); // must release and then re-acquire main lock 必须释放并重新获取主锁。
    Object[] newArray = null;
    if (allocationSpinLock == 0 &&
        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                                 0, 1)) { //CAS 获取扩容的能力，标记我要扩容了
        try {
            int newCap = oldCap + ((oldCap < 64) ?
                                   (oldCap + 2) : // grow faster if small 如果容量比较小扩的多一些。
                                   (oldCap >> 1));//本身已经超过64了，每次只扩张一半
            if (newCap - MAX_ARRAY_SIZE > 0) {    // possible overflow 超出了最大限制
                int minCap = oldCap + 1;
                if (minCap < 0 || minCap > MAX_ARRAY_SIZE)
                    throw new OutOfMemoryError(); //已经最大了，抛出OutOfMemoryError
                newCap = MAX_ARRAY_SIZE; //否则扩容到允许的最大限制
            }
            if (newCap > oldCap && queue == array) //扩容成功，并且当前的源数组没有被其他线程扩容。
                newArray = new Object[newCap]; //创建一个新的数组
        } finally {
            allocationSpinLock = 0; //扩容完成，还原标记
        }
    }
    if (newArray == null) // back off if another thread is allocating
        Thread.yield(); //正好有另一个线程已经在扩容了，放弃CPU
    lock.lock(); //真正要开始扩容才获取锁，
    if (newArray != null && queue == array) {//新数组已经申请好，并且当前并没有被其他线程扩容
        queue = newArray; //改变当前数组指向新的数组
        System.arraycopy(array, 0, newArray, 0, oldCap); //拷贝元素
    }
}


/**
 * 入队
 * Inserts item x at position k, maintaining heap invariant by
 * promoting x up the tree until it is greater than or equal to
 * its parent, or is the root.
   将项x插入到位置k处，通过向上提升x直到它大于或等于它的父元素或根元素，从而保持堆不变。
 * To simplify and speed up coercions and comparisons. the
 * Comparable and Comparator versions are separated into different
 * methods that are otherwise identical. (Similarly for siftDown.)
 * These methods are static, with heap state as arguments, to
 * simplify use in light of possible comparator exceptions.
   简化和加速强制和比较。Comparable和Comparator版本被分为不同的方法，这些方法在其他方面是相同的。
 * 这些方法是静态的，使用堆状态作为参数，以便根据可能的comparator异常简化使用。
   siftUp就是从k开始往上找一个刚好比它小或者相等的祖父节点，然后将其插入到该祖父节点的下方（作为其子节点）。
   在寻找的过程中也会将比它大的祖父节点的位置下移。
 * @param k the position to fill 填补位置
 * @param x the item to insert  要插入的项
 * @param array the heap array  堆数组
 */
private static <T> void siftUpComparable(int k, T x, Object[] array) {
    Comparable<? super T> key = (Comparable<? super T>) x;
    while (k > 0) {
        int parent = (k - 1) >>> 1; //父节点索引
        Object e = array[parent]; //父节点元素
        if (key.compareTo((T) e) >= 0) //找到一个比key小或者相等的父节点跳出循环
            break;
        array[k] = e; //父节点下移
        k = parent;  //继续往上找父节点的父节点
    }
    array[k] = key; //将x插入到比它小或者相等的父节点下方（作为其子节点）。
}


/**
 * 出队
 * Inserts item x at position k, maintaining heap invariant by
 * demoting x down the tree repeatedly until it is less than or
 * equal to its children or is a leaf.
   将项x插入到位置k处，通过重复地将x从树中降级来保持堆不变，直到它小于或等于其子元素或叶节点。
   用x元素与k的最小的子节点比较（如果左子节点比右子节点大，就拿右子节点），如果x小或相等就将x设置为k位置的元素，否则k的最小子节点升级为父节点。
   如果是k的子节点小，继续用刚才升级的子节点（如果是右节点小那就是右子节点）的子节点与x比较，找到最小的一个填充因为k的最小子元素升级空出来的位置，
   直到将x元素插到某个非叶子节点或者已经到达叶子节点了，那么就将x插入最后升级为父节点的叶子节点处。
 * @param k the position to fill
 * @param x the item to insert
 * @param array the heap array
 * @param n heap size
 */
private static <T> void siftDownComparable(int k, T x, Object[] array, int n) {
    if (n > 0) { //队列不为空
        Comparable<? super T> key = (Comparable<? super T>)x;
        int half = n >>> 1;           // loop while a non-leaf 非叶节点时执行循环
        while (k < half) { // k 属于非叶子节点。
            int child = (k << 1) + 1; // assume left child is least（假设左子结点最小） k的左子节点
            Object c = array[child]; // 左子节点元素
            int right = child + 1;   // 右子节点索引
            if (right < n && ((Comparable<? super T>) c).compareTo((T) array[right]) > 0)
                c = array[child = right]; //如果左子节点比右子节点大，就转到更小的右子节点。
            if (key.compareTo((T) c) <= 0)
                break;  //x比k的最小的子节点都小，退出
            array[k] = c; //子节点就是最小的了，将其子节点升级为父节点。
            k = child;    //继续以子节点为父节点往下找子节点的子节点
        }
        array[k] = key; //将x插入到k
    }
}
```

#### ⑤ put/take

```Java
public void put(E var1) {
    this.offer(var1);
}

public E take() throws InterruptedException {
    ReentrantLock var1 = this.lock;
    var1.lockInterruptibly();
    Object var2;
    try {
        // 队列为空时, 阻塞等待
        while((var2 = this.dequeue()) == null) {
            this.notEmpty.await();
        }
    } finally {
        var1.unlock();
    }
    return var2;
}

// 出队的方法
private E dequeue() {
    int var1 = this.size - 1;
    if (var1 < 0) {
        return null;
    } else {
        Object[] var2 = this.queue;
        Object var3 = var2[0];
        Object var4 = var2[var1];
        var2[var1] = null;
        Comparator var5 = this.comparator;
        if (var5 == null) {
            siftDownComparable(0, var4, var2, var1);
        } else {
            siftDownUsingComparator(0, var4, var2, var1, var5);
        }
        this.size = var1;
        return var3;
    }
}
```

⑥ peek

```Java
public E peek() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        // 队列不为空时获取队列第一个元素返回, 并不会从队列移除该元素
        var2 = this.size == 0 ? null : this.queue[0];
    } finally {
        var1.unlock();
    }
    return var2;
}
```

























### 5、SynchronousQueue

​	（并发同步阻塞队列）本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。

​		一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去 集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中 间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商 品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者 中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。
　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:
　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；
　 	但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO（后进先出法 Last In First Out ）队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。

#### ① 类定义

```Java
public class SynchronousQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
static final int NCPUS = Runtime.getRuntime().availableProcessors();
static final int maxTimedSpins;
static final int maxUntimedSpins;
static final long spinForTimeoutThreshold = 1000L;
private transient volatile SynchronousQueue.Transferer<E> transferer;
private ReentrantLock qlock;
private SynchronousQueue.WaitQueue waitingProducers;
private SynchronousQueue.WaitQueue waitingConsumers;
```

#### ③ 构造

```Java
// 默认采用非公平
public SynchronousQueue() {
    this(false);
}
// 可以选择公平和非公平模式
public SynchronousQueue(boolean fair) {
    // 公平使用TransferQueue，先进先出
    // 非公平使用TransferStack，栈顶匹配，栈顶出栈，后进先出
    transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
}
```

#### ④ offer/poll

```Java
public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    return transferer.transfer(e, true, 0) != null;
}
public E poll() {
    return transferer.transfer(null, true, 0);
}

public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    if (transferer.transfer(e, true, unit.toNanos(timeout)) != null)
        return true;
    if (!Thread.interrupted())
        return false;
    throw new InterruptedException();
}
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    E e = transferer.transfer(null, true, unit.toNanos(timeout));
    if (e != null || !Thread.interrupted())
        return e;
    throw new InterruptedException();
}
```

#### ⑤ put/take

```Java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    if (transferer.transfer(e, false, 0) == null) {
        Thread.interrupted();
        throw new InterruptedException();
    }
}

public E take() throws InterruptedException {
    E e = transferer.transfer(null, false, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}
```

#### ⑥ Transferer

​		【1】Transferer是SynchronousQueue的内部抽象类，双栈和双队列算法共享该类。他只有一个transfer方法，用于转移元素，从生产者转移到消费者；或者消费者调用该方法从生产者取数据。

　　【2】Transferer有两个实现类：TransferQueue和TransferStack。

　　【3】这两个类的区别就在于是否公平。TransferQueue是公平的，TransferStack非公平。

构造

```Java
// 堆栈和队列共同的接口，负责执行 put or take
abstract static class Transferer<E> {
    // e 为空的，会直接返回特殊值，不为空会传递给消费者
    // timed 为 true，说明会有超时时间
    abstract E transfer(E e, boolean timed, long nanos);
}
```

#### ⑦ TransferQueue

​	节点

```Java
//队列节点元素
static final class QNode {
    // 当前元素的下一个元素
    volatile QNode next;          
    // 当前元素的值，如果当前元素被阻塞住了，等其他线程来唤醒自己时，其他线程会把自己 set 到 item 里面
    volatile Object item;         
    // 可以阻塞住的当前线程
    volatile Thread waiter;       
    // 节点类型：true是 put，false是 take
    final boolean isData;         
}
```

​	构造

```Java
//队列头结点指针
transient volatile QNode head;
//队列尾结点指针
transient volatile QNode tail;

TransferQueue() {
    QNode h = new QNode(null, false); // initialize to dummy node.
    head = h;
    tail = h;
}
```

​	核心方法

```Java
@SuppressWarnings("unchecked")
E transfer(E e, boolean timed, long nanos) {
    QNode s = null; 
    //根据是否传入数据 判断是获取还是存放 
    boolean isData = (e != null);
    for (;;) {
        // 队列头和尾的临时变量,队列是空的时候，t=h
        QNode t = tail;
        QNode h = head;
        // tail 和 head 没有初始化时，无限循环，虽然这种 continue 非常耗cpu，但感觉不会碰到这种情况
        // 因为 tail 和 head 在 TransferQueue 初始化的时候，就已经被赋值空节点了
        if (t == null || h == null)         // saw uninitialized value
            continue;                       // spin
        // 首尾节点相同，说明是空队列
        // 或者尾节点的操作和当前节点操作一致
        if (h == t || t.isData == isData) { // empty or same-mode
            QNode tn = t.next;
            if (t != tail)                  //直至拿到尾节点
                continue;
            if (tn != null) {               // lagging tail
                advanceTail(t, tn);
                continue;
            }
            //超时直接返回 null
            if (timed && nanos <= 0)        // can't wait
                return null;
            //构建新节点
            if (s == null)
                s = new QNode(e, isData);
            //将新建节点塞入队列
            if (!t.casNext(null, s))        // failed to link in
                continue;

            advanceTail(t, s);             
            // 阻塞住自己
            Object x = awaitFulfill(s, e, timed, nanos);
            if (x == s) {                   // wait was cancelled
                clean(t, s);
                return null;
            }

            if (!s.isOffList()) {           // not already unlinked
                advanceHead(t, s);          // unlink if head
                if (x != null)              // and forget fields
                    s.item = s;
                s.waiter = null;
            }
            return (x != null) ? (E)x : e;

        } 
        // 队列不为空，并且当前操作和队尾不一致，也就是说当前操作是队尾是对应的操作
        // 比如说队尾是因为 take 被阻塞的，那么当前操作必然是 put
        else {
            // 也就是这行代码体现出队列的公平，每次操作时，从头开始按照顺序进行操作
            QNode m = h.next;              
            if (t != tail || m == null || h != head)
                continue;                   // inconsistent read
            Object x = m.item;
            if (isData == (x != null) ||    // m already fulfilled
                x == m ||                   // m cancelled
                !m.casItem(x, e)) {         // lost CAS
                advanceHead(h, m);          // dequeue and retry
                continue;
            }
            // 当前操作放到队头
            advanceHead(h, m);           
            // 释放队头阻塞节点
            LockSupport.unpark(m.waiter);
            return (x != null) ? (E)x : e;
        }
    }
}
```

#### ⑧ TransferStack

​	节点元素

```Java
// 栈中节点的几种类型：
// 1. 消费者（请求数据的）
static final int REQUEST    = 0;
// 2. 生产者（提供数据的）
static final int DATA       = 1;
// 3. 二者正在匹配中
static final int FULFILLING = 2;

// 栈中的节点
static final class SNode {
    // 下一个节点
    volatile SNode next;        
    volatile SNode match;       // the node matched to this
    // 等待着的线程
    volatile Thread waiter;    
    Object item;                
    // 模式，也就是节点的类型，是消费者，是生产者，还是正在匹配中
    int mode;
}
```

​	核心方法

```Java
// TransferStack.transfer()方法
E transfer(E e, boolean timed, long nanos) {
    SNode s = null; // constructed/reused as needed
    // 根据e是否为null决定是生产者还是消费者
    int mode = (e == null) ? REQUEST : DATA;
    // 自旋+CAS
    for (;;) {
        // 栈顶元素
        SNode h = head;
        // 栈顶没有元素，或者栈顶元素跟当前元素是一个模式的
        // 也就是都是生产者节点或者都是消费者节点
        if (h == null || h.mode == mode) {  // empty or same-mode
            // 如果有超时而且已到期
            if (timed && nanos <= 0) {      // can't wait
                // 如果头节点不为空且是取消状态
                if (h != null && h.isCancelled())
                    // 就把头节点弹出，并进入下一次循环
                    casHead(h, h.next);     // pop cancelled node
                else
                    // 否则，直接返回null（超时返回null）
                    return null;
            } else if (casHead(h, s = snode(s, e, h, mode))) {
                // 入栈成功（因为是模式相同的，所以只能入栈）
                // 调用awaitFulfill()方法自旋+阻塞当前入栈的线程并等待被匹配到
                SNode m = awaitFulfill(s, timed, nanos);
                // 如果m等于s，说明取消了，那么就把它清除掉，并返回null
                if (m == s) {               // wait was cancelled
                    clean(s);
                    // 被取消了返回null
                    return null;
                }
                
                // 到这里说明匹配到元素了
                // 因为从awaitFulfill()里面出来要不被取消了要不就匹配到了
                // 如果头节点不为空，并且头节点的下一个节点是s
                // 就把头节点换成s的下一个节点
                // 也就是把h和s都弹出了
                // 也就是把栈顶两个元素都弹出了
                if ((h = head) != null && h.next == s)
                    casHead(h, s.next);     // help s's fulfiller
                // 根据当前节点的模式判断返回m还是s中的值
                return (E) ((mode == REQUEST) ? m.item : s.item);
            }
        } else if (!isFulfilling(h.mode)) { // try to fulfill
            // 到这里说明头节点和当前节点模式不一样
            // 如果头节点不是正在匹配中
            
            // 如果头节点已经取消了，就把它弹出栈
            if (h.isCancelled())            // already cancelled
                casHead(h, h.next);         // pop and retry
            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
                // 头节点没有在匹配中，就让当前节点先入队，再让他们尝试匹配
                // 且s成为了新的头节点，它的状态是正在匹配中
                for (;;) { // loop until matched or waiters disappear
                    SNode m = s.next;       // m is s's match
                    // 如果m为null，说明除了s节点外的节点都被其它线程先一步匹配掉了
                    // 就清空栈并跳出内部循环，到外部循环再重新入栈判断
                    if (m == null) {        // all waiters are gone
                        casHead(s, null);   // pop fulfill node
                        s = null;           // use new node next time
                        break;              // restart main loop
                    }
                    SNode mn = m.next;
                    // 如果m和s尝试匹配成功，就弹出栈顶的两个元素m和s
                    if (m.tryMatch(s)) {
                        casHead(s, mn);     // pop both s and m
                        // 返回匹配结果
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    } else                  // lost match
                        // 尝试匹配失败，说明m已经先一步被其它线程匹配了
                        // 就协助清除它
                        s.casNext(m, mn);   // help unlink
                }
            }
        } else {                            // help a fulfiller
            // 到这里说明当前节点和头节点模式不一样
            // 且头节点是正在匹配中
            
            SNode m = h.next;               // m is h's match
            if (m == null)                  // waiter is gone
                // 如果m为null，说明m已经被其它线程先一步匹配了
                casHead(h, null);           // pop fulfilling node
            else {
                SNode mn = m.next;
                // 协助匹配，如果m和s尝试匹配成功，就弹出栈顶的两个元素m和s
                if (m.tryMatch(h))          // help match
                    // 将栈顶的两个元素弹出后，再让s重新入栈
                    casHead(h, mn);         // pop both h and m
                else                        // lost match
                    // 尝试匹配失败，说明m已经先一步被其它线程匹配了
                    // 就协助清除它
                    h.casNext(m, mn);       // help unlink
            }
        }
    }
}

// 三个参数：需要等待的节点，是否需要超时，超时时间
SNode awaitFulfill(SNode s, boolean timed, long nanos) {
    // 到期时间
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    // 当前线程
    Thread w = Thread.currentThread();
    // 自旋次数
    int spins = (shouldSpin(s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
        // 当前线程中断了，尝试清除s
        if (w.isInterrupted())
            s.tryCancel();
        
        // 检查s是否匹配到了元素m（有可能是其它线程的m匹配到当前线程的s）
        SNode m = s.match;
        // 如果匹配到了，直接返回m
        if (m != null)
            return m;
        
        // 如果需要超时
        if (timed) {
            // 检查超时时间如果小于0了，尝试清除s
            nanos = deadline - System.nanoTime();
            if (nanos <= 0L) {
                s.tryCancel();
                continue;
            }
        }
        if (spins > 0)
            // 如果还有自旋次数，自旋次数减一，并进入下一次自旋
            spins = shouldSpin(s) ? (spins-1) : 0;
        
        // 后面的elseif都是自旋次数没有了
        else if (s.waiter == null)
            // 如果s的waiter为null，把当前线程注入进去，并进入下一次自旋
            s.waiter = w; // establish waiter so can park next iter
        else if (!timed)
            // 如果不允许超时，直接阻塞，并等待被其它线程唤醒，唤醒后继续自旋并查看是否匹配到了元素
            LockSupport.park(this);
        else if (nanos > spinForTimeoutThreshold)
            // 如果允许超时且还有剩余时间，就阻塞相应时间
            LockSupport.parkNanos(this, nanos);
    }
}

// SNode里面的方向，调用者m是s的下一个节点
// 这时候m节点的线程应该是阻塞状态的
boolean tryMatch(SNode s) {
    // 如果m还没有匹配者，就把s作为它的匹配者
    if (match == null &&
        UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) {
        Thread w = waiter;
        if (w != null) {    // waiters need at most one unpark
            waiter = null;
            // 唤醒m中的线程，两者匹配完毕
            LockSupport.unpark(w);
        }
        // 匹配到了返回true
        return true;
    }
    // 可能其它线程先一步匹配了m，返回其是否是s
    return match == s;
}
```

#### ⑨ 总结

　　【1】是一个没有数据缓冲的BlockingQueue，容量为0，它不会为队列中元素维护存储空间，它只是多个线程之间数据交换的媒介。

　　【2】数据结构：链表，在其内部类中维护了数据

　　　　　　先消费（take），后生产(put)；

　　　　　　　　第一个线程Thread0是消费者访问，此时队列为空，则入队（创建Node结点并赋值）

　　　　　　　　第二个线程Thread1也是消费者访问，与队尾模式相同，继续入队

　　　　　　　　第三个线程Thread2是生产者，携带了数据e，与队尾模式不同，不进行入队操作。直接将该线程携带的数据e返回给队首的消费者，并唤醒队首线程Thread1（默认非公平策略是栈结构），出队。

　　　　　　反之，先生产(put)后消费(take),原理一样

　　【3】锁：CAS+自旋（无锁）【阻塞：自旋了一定次数后调用 LockSupport.park()】

　　【4】存取调用同一个方法：transfer()

　　　　　　put、offer 为生产者，携带了数据 e，为 Data 模式，设置到 SNode或QNode 属性中。

　　　　　　take、poll 为消费者，不携帯数据，为 Request 模式，设置到 SNode或QNode属性中。

　　【5】过程

　　　　　　线程访问阻塞队列，先判断队尾节点或者栈顶节点的 Node 与当前入队模式是否相同

　　　　　　相同则构造节点 Node 入队，并阻塞当前线程，元素 e 和线程赋值给 Node 属性

　　　　　　不同则将元素 e（不为 null） 返回给取数据线程，队首或栈顶线程被唤醒，出队

　　【6】公平模式：TransferQueue，队尾匹配(判断模式)，队头出队，先进先出

　　【7】非公平模式（默认策略）：TransferStack，栈顶匹配，栈顶出栈，后进先出

　　【8】应用场景

　　　　　　SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。

　　　　　　SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。

### 6、LinkedBlockingDeque

​	（基于链表的FIFO双端阻塞队列）

​		【1】LinkedBlockingDeque是一个基于链表实现的双向阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，可以看做无界队列，但也可以设置容量限制，作为有界队列。

　　【2】相比于其他阻塞队列，LinkedBlockingDeque 多了 addFirst、addLast、peekFirst、peekLast 等方法。以first结尾的方法，表示插入、获取或移除双端队列的第一个元素。以 last 结尾的方法，表示插入、获取或移除双端队列的最后一个元素。但本质上并没有优化锁的竞争情况，因为不管是从队首还是队尾，都是在竞争同一把锁，只不过数据插入和获取的方式多了。

总结：

​		【1】一个链表阻塞双端无界队列，可以指定容量，默认为 Integer.MAX_VALUE

　　【2】数据结构：链表（同LinkedBlockingQueue，内部类Node存储元素）

　　【3】锁：ReentrantLock（同ArrayBlockingQueue）存取是同一把锁，操作的是同一个数组对象

　　【4】阻塞对象（notEmpty【出队：队列count=0，无元素可取时，阻塞在该对象上】，notFull【入队：队列count=capacity，放不进元素时，阻塞在该对象上】）

　　【5】入队，首尾都可以，均可以添加删除。

　　【6】出队，首尾都可以，均可以添加删除。

　　【7】应用场景：常用于 “工作窃取算法”。

#### ① 类定义

```Java
public class LinkedBlockingDeque<E> extends AbstractQueue<E> implements BlockingDeque<E>, Serializable {
```

#### ② 成员变量

```Java
transient Node<E> first;		// 链表头  本身是不存储任何元素的，初始化时item指向null
transient Node<E> last;			// 链表尾
private transient int count;	// 元素数量
private final int capacity;		// 容量,指定容量就是有界队列
final ReentrantLock lock = new ReentrantLock(); //重入锁
// 当队列无元素时，锁会阻塞在notEmpty条件上，等待其它线程唤醒
private final Condition notEmpty = lock.newCondition();
// 当队列满了时，锁会阻塞在notFull上，等待其它线程唤醒
private final Condition notFull = lock.newCondition();
```

#### ③ 构造

```Java
public LinkedBlockingDeque() {
    this(Integer.MAX_VALUE); // 如果没传容量，就使用最大int值初始化其容量
}

public LinkedBlockingDeque(int capacity) {
    if (capacity <= 0) throw new IllegalArgumentException();
    this.capacity = capacity;
}

public LinkedBlockingDeque(Collection<? extends E> c) {
    this(Integer.MAX_VALUE);
    final ReentrantLock lock = this.lock;
    lock.lock(); // 为保证可见性而加的锁
    try {
        for (E e : c) {
            if (e == null)
                throw new NullPointerException();
            //从尾部插入元素，插入失败抛出异常
            if (!linkLast(new Node<E>(e)))
                throw new IllegalStateException("Deque full");
        }
    } finally {
        lock.unlock();
    }
}
```

#### ④ 入队方法

```Java
//添加头结点元素
public void addFirst(E e) {
    //如果添加失败，抛出异常
    if (!offerFirst(e))
        throw new IllegalStateException("Deque full");
}

//添加尾结点元素
public void addLast(E e) {
    //如果添加失败，抛出异常
    if (!offerLast(e))
        throw new IllegalStateException("Deque full");
}

//添加头结点元素
public boolean offerFirst(E e) {
    //添加的元素为空 抛出空指针异常
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //这边会加锁，并调用添加头结点插入的核心方法
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return linkFirst(node);
    } finally {
        //解锁
        lock.unlock();
    }
}

//添加尾结点元素
public boolean offerLast(E e) {
    //添加的元素为空 抛出空指针异常
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //这边会加锁，并调用添加尾结点插入的核心方法
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return linkLast(node);
    } finally {
        lock.unlock();
    }
}

//头部插入
private boolean linkFirst(Node<E> node) {
    //当前容量大于队列最大容量时，直接返回插入失败
    if (count >= capacity)
        return false;
    //队列中的头结点
    Node<E> f = first;
    //原来的头结点作为 新插入结点的后一个结点
    node.next = f;
    //替换头结点 为新插入的结点
    first = node;
    //尾结点不存在，将尾结点置为当前新插入的结点
    if (last == null)
        last = node;
    else
        //原来的头结点的上一个结点为当前新插入的结点
        f.prev = node;
    //当前容量增加
    ++count;
    //唤醒读取时因队列中无元素而导致阻塞的线程
    notEmpty.signal();
    return true;
}

//尾部插入
private boolean linkLast(Node<E> node) {
    //当前容量大于队列最大容量时，直接返回插入失败
    if (count >= capacity)
        return false;
    //获取尾节点
    Node<E> l = last;
    //将新插入的前一个节点指向原来的尾节点
    node.prev = l;
    //尾结点设置为新插入的结点
    last = node;
    //头结点为空，新插入的结点作为头节点
    if (first == null)
        first = node;
    else
        //将原尾结点的下一个结点指向新插入的节点
        l.next = node;
    //当前容量增加
    ++count;
    //唤醒读取时因队列中无元素而导致阻塞的线程
    notEmpty.signal();
    return true;
}

//头结点插入
public void putFirst(E e) throws InterruptedException {
    //元素不能为空
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //这边会加锁，并调用添加头结点插入的核心方法
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //头结点如果插入失败，会阻塞该方法，直到取出结点或删除结点时被唤醒
        while (!linkFirst(node))
            notFull.await();
    } finally {
        //解锁
        lock.unlock();
    }
}

//尾结点插入
public void putLast(E e) throws InterruptedException {
    //元素不能为空
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //这边会加锁，并调用添加尾结点插入的核心方法
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //尾结点如果插入失败，会阻塞该方法，直到取出结点或删除结点时被唤醒
        while (!linkLast(node))
            notFull.await();
    } finally {
        lock.unlock();
    }
}

//头结点插入 可指定阻塞时间
public boolean offerFirst(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
    //元素不能为空
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //计算剩余应阻塞时间
    long nanos = unit.toNanos(timeout);
    //这边会加锁，并调用添加头结点插入的核心方法
    final ReentrantLock lock = this.lock;
    //获取可响应中断的锁，保证阻塞时间到期后可重新获得锁
    lock.lockInterruptibly();
    try {
        //头结点如果插入失败，会阻塞该方法，直到取出结点或删除结点时被唤醒
        //或者阻塞时间到期直接返回失败
        while (!linkFirst(node)) {
            if (nanos <= 0)
                return false;
            nanos = notFull.awaitNanos(nanos);
        }
        return true;
    } finally {
        //解锁
        lock.unlock();
    }
}

//头结点插入 可指定阻塞时间
public boolean offerLast(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
    //元素不能为空
    if (e == null) throw new NullPointerException();
    //将元素构造为结点
    Node<E> node = new Node<E>(e);
    //计算剩余应阻塞时间
    long nanos = unit.toNanos(timeout);
    //这边会加锁，并调用添加尾结点插入的核心方法
    final ReentrantLock lock = this.lock;
    //获取可响应中断的锁，保证阻塞时间到期后可重新获得锁
    try {
        //尾结点如果插入失败，会阻塞该方法，直到取出结点或删除结点时被唤醒
        //或者阻塞时间到期直接返回失败
        while (!linkLast(node)) {
            if (nanos <= 0)
                return false;
            nanos = notFull.awaitNanos(nanos);
        }
        return true;
    } finally {
        //解锁
        lock.unlock();
    }
}
```

#### ⑤ 出队方法

```Java
//删除头结点 - 加锁 直接返回结果
public E pollFirst() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //调用删除头结点核心方法
        return unlinkFirst();
    } finally {
        lock.unlock();
    }
}

//删除尾结点 - 加锁 直接返回结果
public E pollLast() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //调用删除尾结点核心方法
        return unlinkLast();
    } finally {
        lock.unlock();
    }
}

//删除头结点 - 加锁，如果删除失败则阻塞
public E takeFirst() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E x;
        //调用删除头结点核心方法
        while ((x = unlinkFirst()) == null)
            //阻塞
            notEmpty.await();
        return x;
    } finally {
        lock.unlock();
    }
}

//删除尾结点 - 加锁，如果删除失败则阻塞
public E takeLast() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E x;
        //调用删除尾结点核心方法
        while ((x = unlinkLast()) == null)
            //阻塞
            notEmpty.await();
        return x;
    } finally {
        lock.unlock();
    }
}

//删除头结点 - 加锁，如果删除失败则阻塞 可以指定阻塞时间
public E pollFirst(long timeout, TimeUnit unit)
        throws InterruptedException {
    //计算应阻塞时间
    long nanos = unit.toNanos(timeout);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        E x;
        //调用删除头结点核心方法
        while ((x = unlinkFirst()) == null) {
            if (nanos <= 0)
                //阻塞时间过期，返回结果
                return null;
            //阻塞 并指定阻塞时间
            nanos = notEmpty.awaitNanos(nanos);
        }
        return x;
    } finally {
        lock.unlock();
    }
}

//删除尾结点 - 加锁，如果删除失败则阻塞 可以指定阻塞时间
public E pollLast(long timeout, TimeUnit unit)
        throws InterruptedException {
    //计算应阻塞时间
    long nanos = unit.toNanos(timeout);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        E x;
        //调用删除尾结点核心方法
        while ((x = unlinkLast()) == null) {
            if (nanos <= 0)
                //阻塞时间过期，返回结果
                return null;
            //阻塞 并指定阻塞时间
            nanos = notEmpty.awaitNanos(nanos);
        }
        return x;
    } finally {
        lock.unlock();
    }
}

//删除头结点
private E unlinkFirst() {
    //获取当前头结点
    Node<E> f = first;
    //头结点为空 返回空
    if (f == null)
        return null;
    //获取头结点的下一个结点
    Node<E> n = f.next;
    //获取头结点元素(记录return需要用到的删除了哪个元素)
    E item = f.item;
    //将头结点元素置为null
    f.item = null;
    //将头结点的下一个结点指向自己 方便gc
    f.next = f;
    //设置头结点为原头结点的下一个结点
    first = n;
    //若原头结点的下一个结点不存在（队列中没有了结点）
    if (n == null)
        //将尾结点也置为null
        last = null;
    else
        //新的头结点的前一个结点指向null，因为他已经作为了头结点 所以不需要指向上一个结点
        n.prev = null;
    //当前数量减少
    --count;
    //唤醒因添加元素时队列容量满导致阻塞的线程
    notFull.signal();
    //返回原来的头结点中的元素
    return item;
}

//删除尾结点
private E unlinkLast() {
    //获取当前尾结点
    Node<E> l = last;
    //尾结点不存在 返回null
    if (l == null)
        return null;
    //获取当前尾结点的上一个结点
    Node<E> p = l.prev;
    //获取当前尾结点中的元素，需要返回记录
    E item = l.item;
    //将当前尾结点的元素置为null
    l.item = null;
    //并将当前尾结点的上一个结点指向自己，方便gc
    l.prev = l;
    //设置新的尾结点，为原来尾结点的前一个结点
    last = p;
    //若无新的尾结点，头结点置为空（队列中没有了结点）
    if (p == null)
        first = null;
    else
        //将新的尾结点的下一个结点指向null，因为他已经为尾结点所以不需要指向下一个结点
        p.next = null;
    //数量减少
    --count;
    //唤醒因添加元素时队列容量满导致阻塞的线程
    notFull.signal();
    //返回原来的尾结点元素
    return item;
}
```



```Java

```



### 7、LinkedTransferQueue

​	无界阻塞队列LinkedTransferQueue，此队列也是基于链表实现，对于所有给定的元素都是先入先出的。LinkedTransferQueue可以算是 LinkedBolckingQueue 和 SynchronousQueue 的合体。SynchronousQueue 内部无法存储元素，当要添加元素的时候，需要阻塞。LinkedBolckingQueue 则内部使用了大量的锁，性能有所下降。

#### ① 类定义

```Java
public class LinkedTransferQueue<E> extends AbstractQueue<E> implements TransferQueue<E>, Serializable {
```

#### ② TransferQueue接口定义

```Java
public interface TransferQueue<E> extends BlockingQueue<E> {
    // 如果可能，立即将元素转移给等待的消费者。 
    // 更确切地说，如果存在消费者已经等待接收它（在 take 或 timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则返回 false。
    boolean tryTransfer(E e);
    // 将元素转移给消费者，如果需要的话等待。 
    // 更准确地说，如果存在一个消费者已经等待接收它（在 take 或timed poll（long，TimeUnit）poll）中，则立即传送指定的元素，否则等待直到元素由消费者接收。
    void transfer(E e) throws InterruptedException;
    // 上面方法的基础上设置超时时间
    boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException;
    boolean hasWaitingConsumer();// 如果至少有一位消费者在等待，则返回 true
    int getWaitingConsumerCount();// 返回等待消费者人数的估计值
}
```

#### ③ 成员变量

```Java
// 是否为多核
private static final boolean MP = Runtime.getRuntime().availableProcessors() > 1;
// 自旋次数
private static final int FRONT_SPINS   = 1 << 7;
// 前驱节点正在处理，当前节点需要自旋的次数
private static final int CHAINED_SPINS = FRONT_SPINS >>> 1;
// // 容忍清除节点失败次数的阈值
static final int SWEEP_THRESHOLD = 32;
// 头节点
transient volatile Node head;
// 尾节点
private transient volatile Node tail;
// 断开被删除节点失败的次数
private transient volatile int sweepVotes;
// xfer方法的入参；立即，不需要等待
private static final int NOW   = 0;
// xfer方法的入参；异步，不会阻塞
private static final int ASYNC = 1;
// xfer方法的入参；同步，会阻塞
private static final int SYNC  = 2;
// xfer方法的入参；带超时时间
private static final int TIMED = 3;
// 不安全类
private static final sun.misc.Unsafe UNSAFE;
// 偏移量
private static final long headOffset;
private static final long tailOffset;
private static final long sweepVotesOffset;

这四个常量值，作为xfer方法的入参，用于标识不同操作类型：
	NOW=0表示即时操作（可能失败），即不会阻塞调用线程：
		poll（获取并移除队首元素，如果队列为空，直接返回null）；tryTransfer（尝试将元素传递给消费者，如果没有等待的消费者，则立即返回false，也不会将元素入队）

	ASYNC=1表示异步操作（必然成功）：
		xfer被操作线程调用时，无论xfer操作过程时候完成，调用者都不会进行阻塞等待。offer,put,add（插入指定元素至队尾，由于是无界队列，所以会立即返回true）；

	SYNC=2表示同步操作（阻塞调用线程）：
		只有xfer操作过程达到了调用线程所期望的结果（或抛出异常），调用者才会继续向下执行，否则就一直处于阻塞状态下。transfer（阻塞直到出现一个消费者线程）；take（从队首移除一个元素，如果队列为空，则阻塞线程）

	TIMED=3表示限时同步操作（限时阻塞调用线程）：
		poll(long timeout, TimeUnit unit)；tryTransfer(E e, long timeout, TimeUnit unit)


    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> k = LinkedTransferQueue.class;
            headOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("head"));
            tailOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("tail"));
            sweepVotesOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("sweepVotes"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}
```

#### ④ 入队

```Java
// 阻塞入队
public void put(E e) {
    xfer(e, true, ASYNC, 0);
}
// 超时入队
public boolean offer(E e, long timeout, TimeUnit unit) {
    xfer(e, true, ASYNC, 0);
    return true;
}
// 入队
public boolean offer(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}
// 入队（无界队列）
public boolean add(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}
```

#### ⑤ 出队

```Java
// 阻塞出队        
public E take() throws InterruptedException {
    E e = xfer(null, false, SYNC, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}
// 超时出队
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    E e = xfer(null, false, TIMED, unit.toNanos(timeout));
    if (e != null || !Thread.interrupted())
        return e;
    throw new InterruptedException();
}
// 出队
public E poll() {
    return xfer(null, false, NOW, 0);
}
```

#### ⑥ 查询

```Java
// 查询头节点元素
public E peek() {
    return firstDataItem();
}
// 统计长度
public int size() {
    return countOfMode(true);
}
// 是否为空
public boolean isEmpty() {
    for (Node p = head; p != null; p = succ(p)) {
        if (!p.isMatched())
            return !p.isData;
    }
    return true;
}
```

#### ⑦ 移交元素

```Java
public boolean tryTransfer(E e) {
    return xfer(e, true, NOW, 0) == null;
}
public void transfer(E e) throws InterruptedException {
    if (xfer(e, true, SYNC, 0) != null) {
        Thread.interrupted(); // failure possible only due to interrupt
        throw new InterruptedException();
    }
}
public boolean tryTransfer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
    if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)
        return true;
    if (!Thread.interrupted())
        return false;
    throw new InterruptedException();
}
```

#### ⑧ 基础方法

```Java
// 修改尾节点
private boolean casTail(Node cmp, Node val) {
    return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
}
// 修改头节点
private boolean casHead(Node cmp, Node val) {
    return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);
}
// 断开被删除节点失败的次数
private boolean casSweepVotes(int cmp, int val) {
    return UNSAFE.compareAndSwapInt(this, sweepVotesOffset, cmp, val);
}
// 获取节点模式
private static int spinsFor(Node pred, boolean haveData) {
    if (MP && pred != null) {
        if (pred.isData != haveData)
            return FRONT_SPINS + CHAINED_SPINS;
        if (pred.isMatched())
            return FRONT_SPINS;
        if (pred.waiter == null)
            return CHAINED_SPINS;
    }
    return 0;
}
// 获取下级节点（自旋遍历）
final Node succ(Node p) {
    Node next = p.next;
    return (p == next) ? head : next;
}
// 获取正确的头节点
private Node firstOfMode(boolean isData) {
    // 从原来头节点开始匹配
    for (Node p = head; p != null; p = succ(p)) {
        // 当前不是已匹配就返回
        if (!p.isMatched())
            return (p.isData == isData) ? p : null;
    }
    return null;
}
// 获取第一个数据节点
final Node firstDataNode() {
    // 从原来头节点开始遍历
    for (Node p = head; p != null;) {
        Object item = p.item;
        // 判断节点模式
        if (p.isData) {
            // 判断是否为已取消节点
            if (item != null && item != p)
                return p;
        }
        // 不是数据节点，并且元素为空，
        // 说明队列里都是消费者
        else if (item == null)
            break;
        // 节点后移
        if (p == (p = p.next))
            p = head;
    }
    return null;
}
// 获取第一个数据节点元素
private E firstDataItem() {
    // 从原来头节点开始遍历
    for (Node p = head; p != null; p = succ(p)) {
        Object item = p.item;
        // 是否为数据节点
        if (p.isData) {
            // 是否为已取消
            if (item != null && item != p)
                return LinkedTransferQueue.<E>cast(item);
        }
        // 数据为空，队列都是消费者
        else if (item == null)
            return null;
    }
    return null;
}
// 统计节点数量
private int countOfMode(boolean data) {
    int count = 0;
    // 从头节点开始遍历
    for (Node p = head; p != null; ) {
        // 不是已匹配模式
        if (!p.isMatched()) {
            // 模式不同
            if (p.isData != data)
                return 0;
            // 统计元素数量
            if (++count == Integer.MAX_VALUE) // saturated
                break;
        }
        // 节点后移
        Node n = p.next;
        if (n != p)
            p = n;
        else {
            count = 0;
            p = head;
        }
    }
    return count;
}
```

#### ⑨ 核心方法

```Java
private E xfer(E e, boolean haveData, int how, long nanos) {
    // 数据模式，数据为空抛异常
    if (haveData && (e == null))
        throw new NullPointerException();
    // 新节点
    Node s = null;
    retry:
    // 自旋
    for (;;) {
        // 从头节点开始遍历
        for (Node h = head, p = h; p != null;) {
            // 获取当前节点是否是Data模式
            boolean isData = p.isData;
            // 获取当前节点元素
            Object item = p.item;
            // 判断p模式，并且不是节点取消item=p
            if (item != p && (item != null) == isData) {
                // 判断p模式跟当前模式是否一样
                if (isData == haveData)
                    // 模式一样说明要么都是put要么都poll
                    break;
                // 模式不同开始匹配
                if (p.casItem(item, e)) {
                    // 能到这儿，说明修改p的item成功，
                    // 需要把p设置为已匹配
                    for (Node q = p; q != h;) {
                        // 取p下级节点
                        Node n = q.next;
                        // 头节点是否变化，没变化就修改头节点
                        if (head == h && casHead(h, n == null ? q : n)) {
                            // 原头节点next设置为自己
                            h.forgetNext();
                            break;
                        }
                        // 能到这，修改失败或头节点改变
                        if ((h = head)   == null ||
                                (q = h.next) == null || !q.isMatched())
                            // 新头节点为空或者next为空，
                            // 或者当前节点已经匹配过，重新自旋
                            break;
                    }
                    // 匹配成功，取消对方等待
                    LockSupport.unpark(p.waiter);
                    return LinkedTransferQueue.<E>cast(item);
                }
            }
            // 没有匹配到，节点后移继续匹配
            Node n = p.next;
            p = (p != n) ? n : (h = head);
        }
        // 能到这儿，说明和队列中存储的节点模式一样
        // 或者队列中没有元素了
        // 先是否为不需要等待
        if (how != NOW) {
            // 创建新节点
            if (s == null)
                s = new Node(e, haveData);
            // 尝试入队
            Node pred = tryAppend(s, haveData);
            // 入队失败，重试
            if (pred == null)
                continue retry;
            // 如果不是异步（同步或者有超时）
            // 就等待被匹配
            if (how != ASYNC)
	// 进入等待
                return awaitMatch(s, pred, e, (how == TIMED), nanos);
        }
        return e;
    }
}
```

入队，队尾拼接元素

```Java
private Node tryAppend(Node s, boolean haveData) {
    // 判断尾节点
    for (Node t = tail, p = t;;) {
        Node n, u;
        // 队列为空
        if (p == null && (p = head) == null) {
            // 修改s为头节点（s入队）
            if (casHead(null, s))
                return s;
        }
        // 判断s是否可以接在队尾
        else if (p.cannotPrecede(haveData))
            return null;
        // 判断队尾是否已经有节点了
        else if ((n = p.next) != null)
            p = p != t && t != (u = tail) ? (t = u) :
                    (p != n) ? n : null;
        // 尝试s加入队尾
        else if (!p.casNext(null, s))
            p = p.next;
        // s已经入队
        else {
            if (p != t) {
                while ((tail != t || !casTail(t, s)) &&
                        (t = tail)   != null &&
                        (s = t.next) != null &&
                        (s = s.next) != null && s != t);
            }
            return p;
        }
    }
}
```

对比SynchronousQueue
相比较 SynchronousQueue 多了一个可以存储的队列，相比较 LinkedBlockingQueue 多了直接传递元素，少了用锁来同步。性能更高，用处更大。

LinkedTransferQueue是 SynchronousQueue 和 LinkedBlockingQueue 的合体，性能比 LinkedBlockingQueue 更高（没有锁操作），比 SynchronousQueue能存储更多的元素。

当 put 时，如果有等待的线程，就直接将元素 “交给” 等待者， 否则直接进入队列。

put和 transfer 方法的区别是，put 是立即返回的， transfer 是阻塞等待消费者拿到数据才返回。transfer方法和 SynchronousQueue的 put 方法类似。



## 并发集合

(1) List

​	`CopyOnWriteArrayList`
(2) Set

​	`CopyOnWriteArraySet`
​	`ConcurrentSkipListSet`：是线程安全的有序的集合(相当于线程安全的TreeSet)；它继承于AbstractSet，并实现了NavigableSet接口。ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。
(3) Map

​	`ConcurrentHashMap`：是线程安全的哈希表；它继承于AbstractMap类，并且实现ConcurrentMap接口。	ConcurrentHashMap是通过“锁分段”来实现的，它支持并发。
​	`ConcurrentSkipListMap`：是线程安全的有序的哈希表; 它继承于AbstractMap类，并且实现	ConcurrentNavigableMap接口。ConcurrentSkipListMap是通过“跳表”来实现的，它支持并发。
(4) Queue

​	可以从以下两个维度来分类。一个维度是阻塞与非阻塞，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。

​	另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。

- `ArrayBlockingQueue`是数组实现的线程安全的有界的阻塞队列。

- `LinkedBlockingQueue`是单向链表实现的(指定大小)阻塞队列，该队列按 FIFO（先进先出）排序元素

- `LinkedBlockingDeque`是双向链表实现的(指定大小)双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式。

- `ConcurrentLinkedQueue`是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。

- `ConcurrentLinkedDeque`是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。

  Queue分类

- 单端阻塞队列
  ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。内部一般会持有一个队列，这个队列可以是数组（其实现是 ArrayBlockingQueue）也可以是链表（其实现是 LinkedBlockingQueue）；甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好；PriorityBlockingQueue 支持按照优先级出队；DelayQueue 支持延时出队。

- 双端阻塞队列：其实现是 LinkedBlockingDeque。
- 单端非阻塞队列：其实现是 ConcurrentLinkedQueue。
- 双端非阻塞队列：其实现是 ConcurrentLinkedDeque。
  只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的，所以在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。

