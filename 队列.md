---
typora-root-url: 队列
typora-copy-images-to: 队列
---

# 队列

## Queue

```java
public interface Queue<E> extends Collection<E> {
    // offer，add区别： 一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。 这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。
    boolean add(E var1);
    boolean offer(E var1);
    // poll，remove区别： remove() 和 poll() 方法都是从队列中删除第一个元素（head）。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。
    E remove();
    E poll();
    // peek，element区别： element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。
    E element();
    E peek();
}
```



## 非阻塞队列

### ArrayDeque（数组双端队列）

`ArrayDeque`采用了循环数组的方式来完成双端队列的功能。

- 当头尾索引相遇的时候，两倍扩容
- 非线程安全的，不支持并发访问和修改。
- 支持fast-fail.
- 作为栈使用的话比比栈要快,当队列使用比linklist要快。
- 不允许null值
- 对头尾添加删除元素效率很高。但是删除中间元素的话，需要拷贝数组。拷贝头和尾距离删除元素位置近的那一段，为了提高效率。
- 默认数组大小是8



### PriorityQueue（优先级队列）

​	`PriorityQueue` 类实质上维护了一个有序列表。加入到 `Queue` 中的元素根据它们的天然排序（通过其 `java.util.Comparable` 实现）或者根据传递给构造函数的 `java.util.Comparator` 实现来定位。

### ConcurrentLinkedQueue（基于链表的并发队列）

​	`ConcurrentLinkedQueue` 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小，`ConcurrentLinkedQueue` 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。





## 阻塞队列

`BlockingQueue`的核心方法：

​	`BlockingQueue` 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：

​	1、抛出异常；

​	2、返回特殊值（null 或 true/false，取决于具体的操作）；

​	3、阻塞等待此操作，直到这个操作成功；

​	4、阻塞等待此操作，直到成功或者超时指定时间。

|      | **抛出异常** | **特殊值** | **阻塞**         | **超时**             |
| ---- | ------------ | ---------- | ---------------- | -------------------- |
| 插入 | add(e)       | offer(e)   | put(e)           | offer(e, time, unit) |
| 删除 | remove()     | poll()     | take()           | poll(time, unit)     |
| 获取 | element()    | peek()     | *not applicable* | *not applicable*     |

放入数据：

　　offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,
　　　　则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）
　　offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中
　　　　加入BlockingQueue，则返回失败。
　　put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断
　　　　直到BlockingQueue里面有空间再继续.
获取数据：
　　poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,
　　　　取不到时返回null;
　　poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，
　　　　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。
　　take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到
　　　　BlockingQueue有新的数据被加入; 
　　drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 
　　　　通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。

![image-20240110100948431](/image-20240110100948431.png)

### 1、ArrayBlockingQueue

​	（基于数组的并发阻塞队列） 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。

​	基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了 一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。
　　 ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于 LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的 完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任 何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而 在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。

#### ① 类定义

```Java
public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
final Object[] items;				// 队列元素存储的数组
int takeIndex;						// 出队时的下标
int putIndex;						// 入队时的下标
int count;							// 队列中元素的总数
final ReentrantLock lock;			// 入队和出队锁, 同一把锁
private final Condition notEmpty;	// 非空条件
private final Condition notFull;	// 非满条件
```

#### ③ 构造

```Java
// 指定初始容量
public ArrayBlockingQueue(int var1) {
    this(var1, false);
}
// 指定初始容量以及是否使用公平锁
public ArrayBlockingQueue(int var1, boolean var2) {
    this.itrs = null;
    if (var1 <= 0) {
        throw new IllegalArgumentException();
    } else {
        this.items = new Object[var1];
        this.lock = new ReentrantLock(var2);
        this.notEmpty = this.lock.newCondition();
        this.notFull = this.lock.newCondition();
    }
}
// 从一个集合将数据同步到指定大小并且指定是否公平的队列中
public ArrayBlockingQueue(int var1, boolean var2, Collection<? extends E> var3) {
```

#### ④ add/peek

​	add/peek是一对互斥的操作，add向队列种放入元素，peek取出元素。

```Java
public boolean add(E var1) {
    return super.add(var1);
}
// super.add(var1)
public boolean add(E var1) {
    // 其实就是调用的offer方法,  只是当offer成功了返回true, 失败了抛异常提示队列满了
    if (this.offer(var1)) { 
        return true;
    } else {
        throw new IllegalStateException("Queue full");
    }
}

public E peek() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        // 只是返回出队的元素, 并不真正执行出队逻辑, 元素还在队列中
        var2 = this.itemAt(this.takeIndex);
    } finally {
        var1.unlock();
    }
    return var2;
}
final E itemAt(int var1) {
    return this.items[var1];
}
```

#### ⑤ offer/poll

​	offer/poll是一对互斥的操作，offer向队列种放入元素，poll取出元素

```Java
public boolean offer(E var1) {
    checkNotNull(var1); // 检查, 如果添加的元素为null, 就抛空指针异常
    ReentrantLock var2 = this.lock;
    var2.lock();	// 加锁

    boolean var3;
    try {
        // 当记录的队列总数(count默认为0)与队列长度不一致时, 表示队列没有满, 可以入队
        if (this.count != this.items.length) {
            this.enqueue(var1); // 入队的方法
            var3 = true;
            return var3;
        }
        var3 = false; // 队列满了直接返回false
    } finally {
        var2.unlock(); // 释放锁
    }
    return var3;
}
// 入队的方法, 将元素从数组的下标为0开始添加
private void enqueue(E var1) {
    Object[] var2 = this.items;
    var2[this.putIndex] = var1;
    if (++this.putIndex == var2.length) {
        this.putIndex = 0;
    }

    ++this.count;
    this.notEmpty.signal();
}

public E poll() {
    ReentrantLock var1 = this.lock;
    var1.lock();
    Object var2;
    try {
        var2 = this.count == 0 ? null : this.dequeue();
    } finally {
        var1.unlock();
    }
    return var2;
}

private E dequeue() {
    Object[] var1 = this.items;
    Object var2 = var1[this.takeIndex];
    var1[this.takeIndex] = null;
    if (++this.takeIndex == var1.length) {
        this.takeIndex = 0;
    }
    --this.count;
    if (this.itrs != null) {
        this.itrs.elementDequeued();
    }
    this.notFull.signal();
    return var2;
}
```

offer/poll，带超时的入队出队

```Java
public boolean offer(E var1, long var2, TimeUnit var4) throws InterruptedException {
    checkNotNull(var1);
    long var5 = var4.toNanos(var2);
    ReentrantLock var7 = this.lock;
    var7.lockInterruptibly(); // 允许打断, 会抛出InterruptedException
    boolean var8;
    try {
        while(this.count == this.items.length) { // 队列满时
            if (var5 <= 0L) {
                var8 = false;
                return var8; // 超时返回false
            }
            var5 = this.notFull.awaitNanos(var5); // 超时的notFull条件等待
        }
        this.enqueue(var1); // 未超时, 并且队列未满则入队
        var8 = true;
    } finally {
        var7.unlock();
    }
    return var8;
}

public E poll(long var1, TimeUnit var3) throws InterruptedException {
    long var4 = var3.toNanos(var1);
    ReentrantLock var6 = this.lock;
    var6.lockInterruptibly();

    try {
        Object var7;
        while(this.count == 0) {
            if (var4 <= 0L) {
                var7 = null;
                return var7; // 超时返回null
            }

            var4 = this.notEmpty.awaitNanos(var4); // 带超时的notEmpty条件等待
        }

        var7 = this.dequeue(); // 出队
        return var7;
    } finally {
        var6.unlock();
    }
}
```

#### ⑥ put/take

​	put/take是一对互斥的操作，put向队列种放入元素，take取出元素,其实现方式和add/peek不一样。

```Java
public void put(E var1) throws InterruptedException {
    checkNotNull(var1);
    ReentrantLock var2 = this.lock;
    var2.lockInterruptibly();  // 允许被打断, 会抛出InterruptedException
    try {
        while(this.count == this.items.length) {
            this.notFull.await(); // 队列满了, 则notFull条件等待
        }
        this.enqueue(var1); // 否则入队, 根据putIndex的位置添加数据到数组
    } finally {
        var2.unlock();
    }
}

public E take() throws InterruptedException {
    ReentrantLock var1 = this.lock;
    var1.lockInterruptibly();
    Object var2;
    try {
        while(this.count == 0) {
            this.notEmpty.await(); // 队列为空，则notEmpty条件等待
        }
        var2 = this.dequeue();// 否则队列有数据, 就正常出队
    } finally {
        var1.unlock();
    }
    return var2;
}
```

#### ⑦ 添加方法比较

| 序号 | 方法名                                  | 队列满时处理方式                        | 方法返回值 |
| ---- | --------------------------------------- | --------------------------------------- | ---------- |
| 1    | add(E e)                                | 抛出“Queue full”异常                    | boolean    |
| 2    | offer(E e)                              | 返回false                               | boolean    |
| 3    | put(E e)                                | 线程阻塞，直到中断或被唤醒              | void       |
| 4    | offer(E e, long timeout, TimeUnit unit) | 在规定时间内重试，超过规定时间返回false | boolean    |

#### ⑧ 取出方法比较

| 序号 | 方法名                            | 队列空时处理方式                       | 方法返回值 |
| ---- | --------------------------------- | -------------------------------------- | ---------- |
| 1    | peek()                            | 返回null                               | E          |
| 2    | poll()                            | 返回null                               | E          |
| 3    | take()                            | 线程阻塞，指定中断或被唤醒             | E          |
| 4    | poll(long timeout, TimeUnit unit) | 在规定时间内重试，超过规定时间返回null | E          |

### 2、LinkedBlockingQueue 

​	LinkedBlockingQueue是一个底层用单向链表实现的有界阻塞队列，和ArrayBlockingQueue一样，采用ReentrantLock来控制并发，不同的是它使用了两个独占锁来控制消费和生产

​	（基于链表的FIFO阻塞队列）底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。

​		基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列 中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时 （LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
​		作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认 一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。

#### ① 类定义

```Java
public class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
```

#### ② 成员变量

```Java
private final int capacity;							// 定义队列容量
private final AtomicInteger count;					// 队列实际大小
transient LinkedBlockingQueue.Node<E> head;			// 头节点
private transient LinkedBlockingQueue.Node<E> last;	// 尾节点
private final ReentrantLock takeLock;				// 出队锁
private final Condition notEmpty;					// 非空条件
private final ReentrantLock putLock;				// 入队锁
private final Condition notFull;					// 非满条件
```

#### ③ 构造

```Java
// 无参构造默认大小为Integer最大值
public LinkedBlockingQueue() {
    this(2147483647);
}
// 有参构造, 根据指定的队列大小初始化队列
public LinkedBlockingQueue(int var1) {
    this.count = new AtomicInteger();
    this.takeLock = new ReentrantLock();
    this.notEmpty = this.takeLock.newCondition();
    this.putLock = new ReentrantLock();
    this.notFull = this.putLock.newCondition();
    if (var1 <= 0) {
        throw new IllegalArgumentException();
    } else {
        this.capacity = var1;
        this.last = this.head = new LinkedBlockingQueue.Node((Object)null);
    }
}
// 有参构造, 根据一个集合初始化队列, 默认大小为Integer最大值
public LinkedBlockingQueue(Collection<? extends E> var1) {
    this(2147483647);
}
```

#### ④ offer/poll

```Java
/** 向队列中添加元素，但是不会阻塞 */
public boolean offer(E e) {
    // 判空
    if (e == null) 
        throw new NullPointerException();
    // 获取记录元素数量的count变量
    final AtomicInteger count = this.count;
    // 如果当前队列已经满了，则直接返回false，不进行添加
    if (count.get() == capacity)
        return false;
    
    // 此变量的作用于put方法中一致
    int c = -1;
    // 封装成Node
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    // 因为是添加元素，所以使用put锁进行锁定，这里调用的lock()方法
    // lock方法不响应中断，这里不需要响应中断，所以选择使用lock，
    // 不需要响应中断是因为这个方法并不会阻塞线程
    putLock.lock();
    try {
        // 再次判断当前队列是否满了，为什么再次判断？
        // 因为在上一次判断后，CPU可能暂停了当前线程，转而执行其他线程
        // 在这个过程中可能有其他线程向队列中添加了元素
        if (count.get() < capacity) {
            // 调用enqueue方法将元素添加到队列的尾部
            enqueue(node);
            // 获取入队前的队列总数, 然后count+1
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                // 当入队后总数小于容量, 表示队列还有位置, 则唤醒一个由于队列满了等待入队的线程
                notFull.signal();
        }
    } finally {
        // 解锁
        putLock.unlock();
    }
    // 当入队前如果入队总数为0, 很可能存在消费线程, 所以唤醒一个由于队列为空等待出队的线程
    if (c == 0)
        signalNotEmpty();
    // c记录的是添加前，队列中元素的个数，不可能出现负数，所以此处返回的一定是true
    return c >= 0;
}


public E poll() {
    AtomicInteger var1 = this.count;
    if (var1.get() == 0) {
        return null; // 队列没有数据, 直接返回null
    } else {
        Object var2 = null;
        int var3 = -1;
        ReentrantLock var4 = this.takeLock;
        var4.lock();

        try {
            if (var1.get() > 0) { // 队列不为空
                // 队列不为空时, 出队
                var2 = this.dequeue();
                // 获取入队前的历史总数, 然后var自减
                var3 = var1.getAndDecrement();//var3记录的是出队前的总数
                if (var3 > 1) {
                    // 当队列仍有数据的时候, 唤醒一个由于队列空了等待出队的线程
                    this.notEmpty.signal();
                }
            }
        } finally {
            var4.unlock();
        }
        // 当出队前队列就是满的, 此时很可能存在要入队的线程
        if (var3 == this.capacity) {
            // 所以当出队前就是满的, 则唤醒一个由于队列满了等待入队的线程
            this.signalNotFull();
        }
        return var2;
    }
}
```

offer/poll，带超时的入队出队

```Java
/**
 * 此方法向队列中添加元素，若队列已经满了，则线程被阻塞，但是参数中限制了阻塞时间
 * 若超时后，当前线程还没有添加成功，则不继续等待，直接返回
 * 参数：
 * 	1、timeout：超时时间的数量级，一个long类型的整数
 *	2、unit：timeout的单位，例如TimeUnit.SECOND表示的就是秒
*/
public boolean offer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {
    
    if (e == null) 
        throw new NullPointerException();
    // 将超时时间转换为纳秒
    long nanos = unit.toNanos(timeout);
    // 以下几句与put方法相同
    int c = -1;
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        // 若当前队列已经满了，则线程需要进入等待
        while (count.get() == capacity) {
            // 判断等待的剩余时间是否<=0，若满足此条件，表示等待时间已经超时
            if (nanos <= 0)
                return false;
            // 使用notFull对象让当前线程阻塞，传入需要阻塞的时间，但是这个方法并不精确
            // 所以会返回剩余需要阻塞的时间，这也就是为什么上一句需要判断nanos <= 0
            nanos = notFull.awaitNanos(nanos);
        }
        // 以下操作和put相同
        enqueue(new Node<E>(e));
        c = count.getAndIncrement();
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
    return true;
}

/**
 * 此方法向队列中获取元素，若队列为空线程将会被阻塞，但是需要指定超时时间，
 * 超时后，线程还未获取元素，直接返回；
 * 参数timeout和unit的含义与会超时的offer方法相同，
 * 分别表示超时时间的数量级，已经时间的单位
*/
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    E x = null;
    int c = -1;
    // 将超时时间转换为纳秒
    long nanos = unit.toNanos(timeout);
    // 以下方法与take方法相同，不重复解释
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        // 若队列为空，则线程需要等待
        while (count.get() == 0) {
            // 判断等待的剩余时间，若剩余时间<=0，表示已经超时，直接返回null
            if (nanos <= 0)
                return null;
            // 让当前线程在notEmpty中的等待nanos纳秒，因为awaitNanos方法不精确，
            // 所以这个方法会返回一个值，表示剩余需要等待的时间，所以才有了上一句的if
            nanos = notEmpty.awaitNanos(nanos);
        }
        // 以下代码与take相同，不重复解释
        x = dequeue();
        c = count.getAndDecrement();
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}
```

#### ⑤ put/take

```Java

public void put(E e) throws InterruptedException {
    // 新元素不能为空
    if (e == null) 
        throw new NullPointerException();
    
    // 初始化一个c变量，后面用于记录插入新元素前，队列中元素的个数
    int c = -1;
    // 将新元素封装成一个Node
    Node<E> node = new Node<E>(e);
    // 因为是添加元素，所以这里使用put锁进行线程同步，先获取put锁
    final ReentrantLock putLock = this.putLock;
    // 获取记录元素个数的变量
    final AtomicInteger count = this.count;
    
    // 在正式操作前，先使用putLock加锁，调用的是lockInterruptibly方法
    // 这个方法在在线程被阻塞时可以响应中断，使用它是防止线程一直无法添加成功，
    // 长期被阻塞在此处
    putLock.lockInterruptibly();
    try {
        // 添加元素前线判断队列中元素是否已经满了，
        // 若满了则使用notFull对象，让当前线程阻塞，直到被另一个线程唤醒
        // 使用while而不是if，目的是防止线程被唤醒时，
        // 队列仍然是满的，所以需要重复判断
        while (count.get() == capacity) {
            notFull.await();
        }
        
        // 调用enqueue方法将新节点加入队列的尾部
        enqueue(node);
        // getAndIncrement方法返回count的旧值，然后让count+1
        c = count.getAndIncrement();
        
        /**************关键点1****************/
        // c + 1就是插入当前这个节点后，队列中元素的数量
        // 若插入这个元素后，队列依旧没有满，则唤醒一个生产者线程
        // 也就是向队列中添加元素的线程（前提是有这么一个线程）。
        // 为什么是在添加一个元素后，唤醒另外一个生产者线程，
        // 而不是在有线程获取元素后，唤醒一个生产者线程呢，这不是才正常吗？
        // 答案就是消费者线程使用的是take锁，而唤醒生产者线程需要的是put锁，
        // 为了减少额外加锁解锁的次数，我们就可以在这里唤醒生产者线程，
        // 因为这里在添加元素前，已经获取了put锁了，不需要重复获取。
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        // 解锁
        putLock.unlock();
    }
    
    /**************关键点2****************/
    // c表示插入之前，队列中元素的个数，若插入之前c == 0，
    // 表示在插入前，队列是空，意味着很有可能存在正在等待的消费者线程
    // 于是调用signalNotEmpty方法唤醒一个消费者线程。
    // 可以看到，只有当添加元素之前，队列为空，这里才会唤醒一个消费者线程。
    // 但是可能有多个消费者线程在等待，此时唤醒一个，那剩下的那些怎么办？
    // 答案就是可以在获取元素的方法中唤醒它们，原理就是上面那段很长的注释
    if (c == 0)
        signalNotEmpty();
}
 
/** 此方法将节点加入到链表的末尾 */
private void enqueue(Node<E> node) {
    /*
     * 以下代码可以分解为：
     * last.next = node;
     * last = node
     * 由于构造方法中 this.last = this.head = new LinkedBlockingQueue.Node((Object)null);
     * 所以当第一个元素入队的时候, last.next = node, 也就修改了head的next的指向, 指向了node
     * 然后last = node, 记录最后一个节点的值, head头节点中保存的元素为null, next指向队列第一个元素
     */
    last = last.next = node;
}
 
/** 此方法用于唤醒一个消费者线程 */
private void signalNotEmpty() {
    // 因为消费者线程是获取元素，所以使用的是take锁
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        // notEmpty由take锁创建，所以需要先锁定take锁，再调用signal方法
        // 否则将抛出异常
        notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
}


public E take() throws InterruptedException {
    E x;
    // 此变量的作用与put方法中一致，用来记录插入前，队列中元素的个数
    int c = -1;
    final AtomicInteger count = this.count;
    // 由于是向队列中获取元素，所以使用的是take锁
    final ReentrantLock takeLock = this.takeLock;
    
    // 实际操作前先锁定，调用lockInterruptibly锁定，且这个方法响应中断
    // 此处需要响应中断，因为这个方法会阻塞线程
    takeLock.lockInterruptibly();
    try {
        // 若队列为空，则当前线程需要等待，直到被其他线程唤醒
        while (count.get() == 0) {
            notEmpty.await();
        }
        // 调用dequeue获取队列的队头元素
        x = dequeue();
        // 获得count的值，然后count + 1
        c = count.getAndDecrement();
        
        /*************关键点1***************/
        // 若队列中原来的元素数量>1，则表示当前线程拿走一个元素后，队列中还有元素
        // 于是此处唤醒其他消费者线程，让他们获取元素
        // 此处很关键，对应着put方法中的关键点2（注意是put，而不是此方法take），put方法中，
        // 只有添加元素前，队列为空，才会唤醒一个消费者线程，而剩余的消费者线程在此处唤醒
        // 因为这里已经拿到了take锁，不需要为了唤醒消费者线程再次获取take锁
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    
    /*******************关键点2*******************/
    // 此处判断，若在获取元素之前，队列是满的，那说明很有可能有生产者线程在等待
    // 因为这里拿走了一个元素，所以队列有空位了，于是就唤醒一个生产者线程，添加元素
    // 值得注意的是，等待的生产者线程可能不止一个，这里只唤醒了一个，剩下的怎么办，
    // 答案就在put方法的关键点2那里，由put方法唤醒了剩下的生产者线程
    if (c == capacity)
        signalNotFull();
    return x;
}
 
/** 此方法获取队列头节点的值，并将头节点从队列删除 */
private E dequeue() {
    // 获取头节点
    Node<E> h = head;
    // 获取头节点的下一个节点
    Node<E> first = h.next;
    // 让头节点指向自己，也就是让头节点从链表上断开
    h.next = h; // help GC
    // 设置新的头节点，也就是原来头节点的下一个节点
    head = first;
    // 获取原来头节点的值
    E x = first.item;
    // 将原来头节点的值置为空，有助于垃圾回收
    first.item = null;
    // 返回结果
    return x;
}
```

#### ⑥ peek

```Java
public E peek() {
    if (this.count.get() == 0) {
        return null; // 当队列为空, 直接返回null
    } else {
        ReentrantLock var1 = this.takeLock;
        var1.lock();
        Object var3;
        try {
            LinkedBlockingQueue.Node var2 = this.head.next;
            // 当头节点的下一个节点不为空, 则返回节点内容
            if (var2 != null) {
                var3 = var2.item;
                return var3;
            }
            var3 = null;
        } finally {
            var1.unlock();
        }
        return var3;
    }
}
```



```Java

```



```Java

```



### 3、DelayQueue

​	（延期阻塞队列）

​		DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。
使用场景：
　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。

### 4、PriorityBlockingQueue 

​	（带优先级的无界阻塞队列）无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。

​		基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度， 否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。

### 5、SynchronousQueue

​	（并发同步阻塞队列）本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。

​		一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去 集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中 间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商 品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者 中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。
　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:
　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；
　 	但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO（后进先出法 Last In First Out ）队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。

### 6、LinkedBlockingDeque

​	（基于链表的FIFO双端阻塞队列）

### 7、LinkedTransferQueue

​	（基于链表无界的阻塞队列）



ConcurrentLinkedQueue, （基于链表的并发队列）

















